#!/bin/sh

# git-subtree
# Scott Bronson, 27 May 2009
# based on http://dysinger.net/2008/04/29/replacing-braid-or-piston-for-git-with-40-lines-of-rake/
# also see http://www.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html

# TODO: automatically figure out name of remote from the current dir?
# TODO: is there any way we can avoid squashing?
# TODO: should probably check for repos with no commits; it causes us to fail

# desired usage:
#
# setup:
#   mkdir -p vendor/plugins/will-paginate
#   cd vendor/plugins/will-paginate
#   git-subtree add git://github.com/mislav/will_paginate.git
#   git-subtree merge master
#   git-subtree merge vendor/plugins/will_paginate/tags/v2.3.8
#      ("git-subtree branch" will list the branches you can use)
#
# update:
#   git-subtree update vendor/plugins/will-paginate [branch]
#   cd vendor/plugins/will-paginate
#   git-subtree update [branch]
# 
#   git-subtree diff vendor/plugins/will-paginate
#   cd vendor/plugins/will-paginate
#   git-subtree diff
#
# Environment Variables (should probably convert into cmdline args):
#   DRY_RUN=1 -- show what would happen but don't do it
#   VERBOSE=1 -- display the git commands as we run them
# usage: $ DRY_RUN=1 git-subtree add http://foo

cmdname="git-subtree"
commands="add fetch merge update diff help"


run() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@"
    "$@"
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

# this is a crappy hack to get 'git fetch' to please be quiet.
# there's GOT to be a better way...?
run_quiet() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@" ">/dev/null 2>&1"
    "$@" >/dev/null 2>&1
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

guess_dir_name() {
  # This should match guess_dir_name in builtin-clone.c
  echo "$(basename "$1" .git)"
}

die() {
  echo "$@" >&2
  exit 1
}


add_help=\
"$cmdname add [<name>] <url>: adds a remote repository as a tree.
  name (optional): the name that will refer to this remote (see git remote)
  url: the URL of the reposiotry to fetch.
"
add() {
  if [ "x$2" != "x" ]; then
    # user supplied an explicit remote name
    remotename="$1"
    remoteurl="$2"
  else
    # implicit remote name, need to figure it out for ourselves.
    remoteurl="$1"
    reponame="$(guess_dir_name "$remoteurl")"
    curdir="$(git rev-parse --show-prefix)"
    [ "x$curdir" = "x" ] && die "You need to be in a subdirectory."
    remotename="$curdir$reponame"
  fi

  if [ "x$remotename" = "x" ] || [ "x$remoteurl" = "x" ]; then
    die "usage: $cmdname add <name> <url>"
  fi
  
  run git remote add "$remotename" "$remoteurl"
  run git config remote."$remotename".fetch refs/heads/\*:refs/remotes/"$remotename"/\*
  run git config --add remote."$remotename".fetch refs/tags/\*:refs/remotes/"$remotename"/tags/\*
  run git config remote."$remotename".tagopt --no-tags

  # TODO: how do I suppress "warning: no common commits" and
  # "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]"??
  run_quiet git fetch -q "$remotename"
}


fetch_help=\
"$cmdname fetch [<remote>]: fetches objects from the remote repo
  remote: if unspecified, computed from the current directory.
"
fetch() {
  remotename="$1"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    [ "x$curdir" = "x" ] && die "You either need to be in a subdirectory or specify a branch name."
    remotename=${curdir%/}
    git remote show "$remotename" >/dev/null 2>&1
    [ "$?" != "0" ] && die "$remotename is not a subtree.  Run git remote to show possible subtrees."
  fi

  # TODO: how do I suppress "warning: no common commits" and
  # "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]"??
  run_quiet git fetch -q "$remotename"
}


merge_help=\
"$cmdname merge [remote]
  Merges the branch into the current directory of the repository
"
merge() {
  branch="$1"
  [ "x$branch" = "x" ] && die "usage: $cmdname merge <branch> [<destination>]"

  if [ "x$2" != "x" ]; then
    dest="$2"
  else
    dest="$(git rev-parse --show-prefix)$branch"
    [ "x$dest" = "x" ] && die "you need to be in a subdirectory!"
  fi


  # TODO: why -s ours?  (it's certainly necessary!)
  # upside to squashing: your changes aren't drowned out by an active upstream
  # TODO: how do I suppress "Automatic merge went well; stopped..." and
  # "Squash commit -- not updating HEAD"??
  run git merge --squash -s ours --no-commit "$branch" >/dev/null 2>&1
  # downside: you can't git bisect (right?) or watch upstream over time.
  # the thing to do is to commit all these changes on a branch.  That way,
  # git reset --hard HEAD^ will back out the entire merge, and you can use
  # git log --not to exclude all the upstream noise on the branch.
  # echo git merge -s ours "$branch"

  run git read-tree --prefix="$dest" -u "$branch"
}


# TODO: should I call this pull?
update_help=\
"Fetches changes from the subtree's upstream then merges them.
  $cmdname update <remote> <branch>
  EXAMPLE: git-subtree update upstream upstream/master
"
update() {
  remote="$1"
  branch="$2"

  # TODO: there's GOT to be a way to get the remote name from the branch
  [ "x$remote" = "x" ] || [ "x$branch" = "x" ] && die "usage: $cmdname update <remote> <branch>"

  # TODO: should probably only fetch the objects on our branch.
  # no need to fetch everything.
  # TODO: how do I suppress "warning: no common commits" and
  # "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]"??
  run_quiet git fetch -q "$remote"
  # TODO: how do I suppress "Automatic merge went well; stopped..." and
  # "Squash commit -- not updating HEAD"??
  run git merge --squash -s subtree --no-commit "$branch" >/dev/null 2>&1
}


diff_help=\
"Diffs a subtree against the remote
"
diff() {
  branch="$1"

  [ "x$branch" = "x" ] && die "usage: $cmdname diff <branch>"

  run git diff-tree -p --no-commit-id "$branch"
}



help_help="Shows help text for the given command"

help() {
  if [ "x$1" = "x" ]; then
    echo \
"$cmdname, like git submodule, allows you to place another git project
into a subtree of your current project.  Unlike git submodule, however,
you can still branch and merge when it's in your repo.

   $cmdname add will_paginate git://github.com/mislav/will_paginate.git
   $cmdname merge will_paginate/master vendor/plugins/will_paginate
   git commit   # todo: should commit automatically
"
    return 0
  fi

  for i in $commands; do
    if [ "$i" = "$1" ]; then
      # echo $add_help if user typed 'gitree help add'
      echo "$(eval "echo \"\$${i}_help\"")"
      return 0
    fi
  done

  echo "Unknown command: $1"
  return 1
}



cmd="$1"
for i in $commands; do
  if [ "$i" = "$cmd" ]; then
    shift
    "$cmd" "$@"
    exit $?
  fi
done

if [ "x$cmd" = "x" ]; then
  echo "You must supply a command to execute!"
else
  echo "unknown command: $cmd"
fi
echo "  some $cmdname subcommands: $commands"
exit 1

