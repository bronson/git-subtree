#!/bin/sh

# git-subtree
# Scott Bronson, 27 May 2009
# based on http://dysinger.net/2008/04/29/replacing-braid-or-piston-for-git-with-40-lines-of-rake/
# also see http://www.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html

# This should work under bash, dash, ksh, zsh, hopefully any posix shell.

# TODO: crib from http://github.com/apenwarr/git-subtree/tree/master
#       to extract patches from the subtree.
# TODO: (far in the future) can I have two subtrees cloned from the same
#       upstream?  How does the merge specify which subtree to affect?
# TODO: can I clone another subtree into an already cloned subtree?

# Environment Variables (TODO should convert these into cmdline args):
#   DRY_RUN=1 -- show what would happen but don't do it
#   VERBOSE=1 -- display the git commands as we run them
# usage: $ DRY_RUN=1 git-subtree add http://foo

cmdname="git-subtree"
commands="help clone pull branch fetch merge diff add"


run() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@"
    "$@"
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

# this is a crappy hack to get some git commands to please be quiet.
# git merge: how do I suppress "Automatic merge went well; stopped..." and
#   "Squash commit -- not updating HEAD" messages??
# git fetch: how do I suppress "warning: no common commits" and
#   "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]" messages??
run_quiet() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@" ">/dev/null 2>&1"
    "$@" >/dev/null 2>&1
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

guess_dir_name() {
  # This should match guess_dir_name in builtin-clone.c
  echo "$(basename "$1" .git)"
}

ensure_repo_has_commits() {
  git rev-list --all --max-count=1 >/dev/null 2>&1
  [ "$?" != "0" ] && die "You need at least one commit before you can add a subtree."
}

die() {
  [ -n "$1" ] && echo "$1" >&2
  exit 1
}

# longest_matching_prefix foobar fooby => foob
longest_matching_prefix() {
  a="$1"; b="$2"
  while [ -n "$b" ] && [ "${a#"$b"}" = "$a" ]; do
    b="${b%?}"
  done
  echo "$b"
}

# if a string contains questionable characters, double quote it.
double_quote_escape() {
  str="$1"
  bad_char_pos="$(expr match "$str" '.*[^a-zA-Z0-9_,./:-]')"
  if [ "$bad_char_pos" != "0" ]; then
    str="\"$(echo "$str" | sed 's/\([$`"\]\)/\\\1/g')\""
  fi
  echo $str
}

# prints each shell quoted word on its own line without escapes or delims.
double_quote_parse() {
  # using perl's shellwords.pl is not ideal since it converts '\a' to 'a'
  # but double_quote_escape only produces escaped backslashes so it's OK.
  echo "$1" | perl -e 'require "shellwords.pl";
    while(<>) { for(shellwords($_)) { print "$_\n" } } '
}

# git doesn't offer a way to split a remote tracking branch into the name
# of the remote and the name of the branch.  so, I'll iterate over all the
# remotes looking for the longest match.
# NOTE: sets 2 globals: remote and branch
split_tracking_branch() {
  tracking="$1"

  for line in "$(git remote)"; do
    ttb="${tracking#"$line/"}"
    if [ "$ttb" != "$tracking" ]; then
      if [ $((${#tracking} - ${#ttb})) -gt ${#remote} ]; then
        remote="$line"
        branch="$ttb"
      fi
    fi
  done

  if [ -z "$remote" ] || [ -z "$branch" ]; then
    echo "Could not find remote tracking branch from $tracking?! remote=$remote branch=$branch"
    return 1
  fi
}

# I couldn't find a good way to query the commit history to determine
# the remote tracking branch that the most recent merge came from.
# So, I'll cache that info in /.gitsubtrees and hope that someone
# can figure out how to do this better.  TODO?
store_remote_tracking_branch() {
  tracking="$1"
  directory="${2%/}"

  split_tracking_branch "$tracking"
  [ "$?" != "0" ] && die "Can't save remote tracking branch."

  escdir="$(double_quote_escape "$directory")"
  esctrack="$(double_quote_escape "$tracking")"

  # slurp the file without the old remote, print with the new one
  branchfile="$(git rev-parse --show-cdup).git-subtrees"
  if [ -f "$branchfile" ]; then
    contents="$(grep -v "^$escdir" < "$branchfile")"
  else
    contents="# generated by $cmdname, do not edit!"
  fi
  printf "$contents\n$escdir $esctrack\n" > "$branchfile"

  git add "$branchfile"
}

# can't use grep because it would interpret its metachars (?[] etc) in
# the path.  therefore, loop through each line and match manually.
find_prefix_in_branchfile() {
  prefix="$1"   # already double-quote escaped
  [ -z "$prefix" ] && die "please specify a subtree."

  branchfile="$(git rev-parse --show-cdup).git-subtrees"
  [ ! -f "$branchfile" ] && die "this repo doesn't have any subtrees."

  while read -r line; do
    if [ "${line#"$prefix "}" != "$line" ]; then
      echo "$line"
      return 0
    fi
  done < "$branchfile"

  die "could not find $prefix in known subtrees."
}

find_remote_tracking_branch() {
  directory="${1%/}"

  escdir="$(double_quote_escape "$directory")"
  branchline="$(find_prefix_in_branchfile "$escdir")"
  [ -z "$branchline" ] && die   # message is already printed

  # read each line of double_quote_parse into a variable
  # use a heredoc to ensure the read doesn't occur in a subshell
  bdir= btrack=
  while read -r line; do
    if [ -z "$bdir" ]; then bdir="$line"
    elif [ -z "$btrack"]; then btrack="$line"
    fi
  done <<EOL
$(double_quote_parse "$branchline")
EOL

  [ -z "$bdir" ] && die "could not find bdir in <<$branchline>> for <<$escdir>>"
  [ -z "$btrack" ] && die "could not find btrack in <<$branchline>> for <<$escdir>>"

  echo "$btrack"
}


clone_help=\
"$cmdname clone <repository> [<branch>] [<directory>] [<remote-name>]
  Creates a new subtree checked out to the given branch of the given repo.
  It is equivalent to $cmdname add; $cmdname fetch; $cmdname merge
    repository: the URL of the repository to clone
    branch:     the remote branch to check out, defaults to master
    directory:  the directory to create, defaults to the name of the repo
    remotename: see $cmdname add
"
clone() {
  ensure_repo_has_commits

  remoteurl="$1"
  branch="$2"
  directory="$3"
  remotename="$4"

  curdir="$(git rev-parse --show-prefix)"

  [ "x$remoteurl" = "x" ] && die "usage: $cmdname clone <name> <url>"
  [ "x$branch" = "x" ] && branch="master"
  [ "x$directory" = "x" ] && directory="$(guess_dir_name "$remoteurl")"
  [ "x$remotename" = "x" ] && remotename="$curdir$directory"

  add "$remoteurl" "$remotename"
  fetch "$remotename"
  merge "$remotename/$branch" "$directory"
}


pull_help=\
"$cmdname pull [<branch>] [<directory>] [<remote-name>]
  Pulls down the most recent commits to the remote repository and commits
  them to the subtree.  Equivalent to $cmdname fetch; $cmdname merge
    branch:     the remote branch to check out, defaults to master
    directory:  the directory to create, defaults to the name of the repo
    remotename: see $cmdname add
"
pull() {
  branch="$1"
  directory="$2"
  remotename="$3"

  curdir="$(git rev-parse --show-prefix)"

  [ "x$branch" = "x" ] && branch="master"
  [ "x$directory" = "x" ] && directory="."
  [ "x$remotename" = "x" ] && remotename="${curdir%/}"

  fetch "$remotename"
  merge "$remotename/$branch" "$directory"
}


add_help=\
"$cmdname add <repository> [<remote-name>]
  Adds knowledge of the given subtree to the repo but doesn't check anything
  out.  See $cmdname clone for the easy way to create a subtree.
    repository: the URL of the repository to clone
    remotename: the name to assign to this remote (see git remote)
"
add() {
  ensure_repo_has_commits

  remoteurl="${1%/}"
  remotename="$2"

  [ "x$remoteurl" = "x" ] && die "usage: $cmdname add <name> <url>"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    directory="$(guess_dir_name "$remoteurl")"
    remotename="$curdir$directory"
  fi

  run git remote add "$remotename" "$remoteurl"
  run git config remote."$remotename".fetch refs/heads/\*:refs/remotes/"$remotename"/\*
  run git config --add remote."$remotename".fetch refs/tags/\*:refs/remotes/"$remotename"/tags/\*
  run git config remote."$remotename".tagopt --no-tags
}


branch_help=\
"$cmdname branch [<directory>]
  Displays the branch your subtree is on and the branches that the remote
  provides.  Use $cmdname checkout to switch branches.
    directory: the directory of the subtree, defaults to the current dir.
"
branch() {
  directory="$1"
  [ "$directory" = "." ] && directory=

  absdir="$(git rev-parse --show-prefix)$directory"
  tracking_branch="$(find_remote_tracking_branch "$absdir")"
  [ -z "$tracking_branch" ] && die  # message is already printed
 
  split_tracking_branch "$tracking_branch"
  # now "remote" and "branch" are the components of tracking_branch

  # show all branches for this remote with a star next to the
  # most-recently-merged branch.
  git branch -r | sed -e 's/^\s*//' | while read -r line; do
    b="${line#"$remote/"}"
    if [ "$b" != "$line" ]; then
      if [ "$b" = "$branch" ]; then
        echo "* $b"
      else
        echo "  $b"
      fi
    fi
  done
}


fetch_help=\
"$cmdname fetch [<remote>]: fetches objects from the remote repo
  remote: The name of the remote to fetch from (see git remote).
          Defaults to the current directory relative to git's root.
"
fetch() {
  remotename="$1"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    [ "x$curdir" = "x" ] && die "You either need to be in a subdirectory or specify a branch name."
    remotename="${curdir%/}"
    git remote show "$remotename" >/dev/null 2>&1
    [ "$?" != "0" ] && die "$remotename is not a subtree.  Run git remote to show possible subtrees."
  fi

  run_quiet git fetch -q "$remotename"
}


merge_help=\
"$cmdname merge <branch> [<directory>]
  Merges the subtree into the current repository
    branch:    the remote tracking branch to merge, i.e. remote/master
    directory: where to store the subtree (defaults to the current directory)

  Merging won't take you backward in time.  If you want to remove commits
  from a subtree, it might be easiest just to delete it and re-clone it.
"
merge() {
  branch="$1"
  directory="$2"
  [ "$directory" = "." ] && directory=

  [ "x$branch" = "x" ] && die "usage: $cmdname merge <branch> [<directory>]"
  absdir="$(git rev-parse --show-prefix)$directory"

  if [ "x$directory" = "x" ] || [ -e "$directory" ]; then
    # If the destination already exists, we need to actually merge
    run_quiet git merge -s subtree --no-commit "$branch"
  else
    # otherwise, record a merge and read the tree
    run_quiet git merge -s ours --no-commit "$branch"
    run git read-tree --prefix="$directory" -u "$branch"
  fi

  store_remote_tracking_branch "$branch" "$absdir"
}



diff_help=\
"Diffs a subtree against the remote
"
diff() {
  branch="$1"

  [ "x$branch" = "x" ] && die "usage: $cmdname diff <branch>"

  run git diff-tree -p --no-commit-id "$branch"
}



help_help="Shows help text for the given command"

help() {
  if [ "x$1" = "x" ]; then
# TODO: once the commands settle down, put an example usage into this help text
    echo \
"$cmdname places another git repository into a subtree of your current
project.  It's like git submodule except that you can still branch and
merge when it's in your repo.
"
    return 0
  fi

  for i in $commands; do
    if [ "$i" = "$1" ]; then
      echo
      echo "$(eval "echo \"\$${i}_help\"")"
      echo
      return 0
    fi
  done

  echo "Unknown command: $1"
  return 1
}



cmd="$1"
for i in $commands; do
  if [ "$i" = "$cmd" ]; then
    shift
    "$cmd" "$@"
    exit $?
  fi
done

if [ "x$cmd" = "x" ]; then
  echo "You must supply a command to execute!"
else
  echo "unknown command: $cmd"
fi
echo "  some $cmdname subcommands: $commands"
exit 1

