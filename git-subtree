#!/bin/sh

# git-subtree
# Scott Bronson, 27 May 2009
# based on http://dysinger.net/2008/04/29/replacing-braid-or-piston-for-git-with-40-lines-of-rake/
# also see http://www.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html

# TODO: is there any way we can avoid squashing?
  # TODO: and branch merging instead of just squashing
  # upside to squashing: your changes aren't drowned out by an active upstream
  # downside: you can't git bisect (right?) or watch upstream over time.
  # the thing to do is to commit all these changes on a branch.  That way,
  # git reset --hard HEAD^ will back out the entire merge, and you can use
  # git log --not to exclude all the upstream noise on the branch.
  # echo git merge -s ours "$branch"

# Environment Variables (TODO should convert these into cmdline args):
#   DRY_RUN=1 -- show what would happen but don't do it
#   VERBOSE=1 -- display the git commands as we run them
# usage: $ DRY_RUN=1 git-subtree add http://foo

cmdname="git-subtree"
commands="help clone fetch merge diff add"


run() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@"
    "$@"
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

# this is a crappy hack to get some git commands to please be quiet.
# there's GOT to be a way to get them to only print errors??
# git merge: how do I suppress "Automatic merge went well; stopped..." and
#   "Squash commit -- not updating HEAD" messages??
# git fetch: how do I suppress "warning: no common commits" and
#   "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]" messages??
run_quiet() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@" ">/dev/null 2>&1"
    "$@" >/dev/null 2>&1
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

guess_dir_name() {
  # This should match guess_dir_name in builtin-clone.c
  echo "$(basename "$1" .git)"
}

ensure_repo_has_commits() {
  git rev-list --all --max-count=1 >/dev/null 2>&1
  [ "$?" != "0" ] && die "You need at least one commit before you can add a subtree."
}

die() {
  echo "$@" >&2
  exit 1
}


add_help=\
"$cmdname add <repository> [<remote-name>]
  Adds knowledge of the given subtree to the repo but doesn't check anything
  out.  See $cmdname clone for the easy way to create a subtree.
    repository: the URL of the repository to clone
    remotename: the name to assign to this remote (see git remote)
"
add() {
  ensure_repo_has_commits

  remoteurl="${1%/}"
  remotename="$2"

  [ "x$remoteurl" = "x" ] && die "usage: $cmdname add <name> <url>"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    directory="$(guess_dir_name "$remoteurl")"
    remotename="$curdir$directory"
  fi

  run git remote add "$remotename" "$remoteurl"
  run git config remote."$remotename".fetch refs/heads/\*:refs/remotes/"$remotename"/\*
  run git config --add remote."$remotename".fetch refs/tags/\*:refs/remotes/"$remotename"/tags/\*
  run git config remote."$remotename".tagopt --no-tags
}


clone_help=\
"$cmdname clone <repository> [<branch>] [<directory>] [<remote-name>]
  Creates a new subtree checked out to the given branch of the given repo.
  It is equivalent to $cmdname add; $cmdname fetch; $cmdname merge
    repository: the URL of the repository to clone
    branch:     the remote branch to check out, defaults to master
    directory:  name of the dir to create, defaults to the name of the repo
    remotename: see $cmdname add
"
clone() {
  ensure_repo_has_commits

  remoteurl="$1"
  branch="$2"
  directory="$3"
  remotename="$4"

  [ "x$remoteurl" = "x" ] && die "usage: $cmdname clone <name> <url>"
  [ "x$branch" = "x" ] && branch="master"
  [ "x$directory" = "x" ] && directory="$(guess_dir_name "$remoteurl")"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    remotename="$curdir$directory"
  fi

  add "$remoteurl" "$remotename"
  fetch "$remotename"
  merge "$remotename/$branch" "$(git rev-parse --show-prefix)$directory"
}


fetch_help=\
"$cmdname fetch [<remote>]: fetches objects from the remote repo
  remote: if unspecified, computed from the current directory.
"
fetch() {
  remotename="$1"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    [ "x$curdir" = "x" ] && die "You either need to be in a subdirectory or specify a branch name."
    remotename="${curdir%/}"
    git remote show "$remotename" >/dev/null 2>&1
    [ "$?" != "0" ] && die "$remotename is not a subtree.  Run git remote to show possible subtrees."
  fi

  run_quiet git fetch -q "$remotename"
}


# TODO: merge should accept the directory name relative to the
# cwd.  Currently it requires it relative to the repo root!
merge_help=\
"$cmdname merge [remote]
  Merges the branch into the current directory of the repository
"
merge() {
  branch="$1"
  [ "x$branch" = "x" ] && die "usage: $cmdname merge <branch> [<destination>]"

  if [ "x$2" != "x" ]; then
    dest="$2"
  else
    dest="$(git rev-parse --show-prefix)$branch"
    [ "x$dest" = "x" ] && die "you need to be in a subdirectory!"
  fi

  if [ -e "$(git rev-parse --show-cdup)$dest" ]; then
    # If the destination already exists, we need to merge
    run_quiet git merge --squash -s subtree --no-commit "$branch"
  else
    # otherwise, just record the result as a merge and read the tree
    run_quiet git merge --squash -s ours --no-commit "$branch"
    run git read-tree --prefix="$dest" -u "$branch"
  fi
}



diff_help=\
"Diffs a subtree against the remote
"
diff() {
  branch="$1"

  [ "x$branch" = "x" ] && die "usage: $cmdname diff <branch>"

  run git diff-tree -p --no-commit-id "$branch"
}



help_help="Shows help text for the given command"

help() {
  if [ "x$1" = "x" ]; then
# TODO: once the commands settle down, put an example usage into this help text
    echo \
"$cmdname places another git repository into a subtree of your current
project.  It's like git submodule except that you can still branch and
merge when it's in your repo.
"
    return 0
  fi

  for i in $commands; do
    if [ "$i" = "$1" ]; then
      echo
      echo "$(eval "echo \"\$${i}_help\"")"
      echo
      return 0
    fi
  done

  echo "Unknown command: $1"
  return 1
}



cmd="$1"
for i in $commands; do
  if [ "$i" = "$cmd" ]; then
    shift
    "$cmd" "$@"
    exit $?
  fi
done

if [ "x$cmd" = "x" ]; then
  echo "You must supply a command to execute!"
else
  echo "unknown command: $cmd"
fi
echo "  some $cmdname subcommands: $commands"
exit 1

