#!/bin/sh

# git-subtree
# Scott Bronson, 27 May 2009
# based on http://dysinger.net/2008/04/29/replacing-braid-or-piston-for-git-with-40-lines-of-rake/
# also see http://www.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html

# TODO: is there any way we can avoid squashing?
  # TODO: and branch merging instead of just squashing
  # upside to squashing: your changes aren't drowned out by an active upstream
  # downside: you can't git bisect (right?) or watch upstream over time.
  # the thing to do is to commit all these changes on a branch.  That way,
  # git reset --hard HEAD^ will back out the entire merge, and you can use
  # git log --not to exclude all the upstream noise on the branch.
  # echo git merge -s ours "$branch"

# desired usage:
#
# setup:
#   mkdir -p vendor/plugins/will-paginate
#   cd vendor/plugins/will-paginate
#   git-subtree add git://github.com/mislav/will_paginate.git
#   git-subtree merge master
#   git-subtree merge vendor/plugins/will_paginate/tags/v2.3.8
#      ("git-subtree branch" will list the branches you can use)
#
# update:
#   git-subtree update vendor/plugins/will-paginate [branch]
#   cd vendor/plugins/will-paginate
#   git-subtree update [branch]
# 
#   git-subtree diff vendor/plugins/will-paginate
#   cd vendor/plugins/will-paginate
#   git-subtree diff
#
# Environment Variables (should probably convert into cmdline args):
#   DRY_RUN=1 -- show what would happen but don't do it
#   VERBOSE=1 -- display the git commands as we run them
# usage: $ DRY_RUN=1 git-subtree add http://foo

cmdname="git-subtree"
commands="clone fetch merge diff help"


run() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@"
    "$@"
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

# this is a crappy hack to get some git commands to please be quiet.
# there's GOT to be a way to get them to only print errors??
# git merge: how do I suppress "Automatic merge went well; stopped..." and
#   "Squash commit -- not updating HEAD" messages??
# git fetch: how do I suppress "warning: no common commits" and
#   "From file:////tmp/tmtest.MnYyIf/upstream * [new branch]" messages??
run_quiet() {
  if [ "x$DRY_RUN" = "x" ]; then
    [ "x$VERBOSE" != "x" ] && echo "Running: $@" ">/dev/null 2>&1"
    "$@" >/dev/null 2>&1
    [ "x$VERBOSE" != "x" ] && echo " Result: $?"
  else
    echo "Not running: $@"
  fi
}

guess_dir_name() {
  # This should match guess_dir_name in builtin-clone.c
  echo "$(basename "$1" .git)"
}

die() {
  echo "$@" >&2
  exit 1
}


clone_help=\
"$cmdname clone <repository> [<branch>] [<directory>] [<remote-name>]
  Creates a new subtree checked out to the given branch of the given repo.
  - url: the URL of the repository to clone
  - branch: the remote branch to check out, defaults to master
  - directory: name of the dir to create, defaults to the name of the repo
  - remotename: the name to assign to this remote (see git remote)
"
clone() {
  git rev-list --all --max-count=1 >/dev/null 2>&1
  [ "$?" != "0" ] && die "You need at least one commit before you can clone a subtree."

  remoteurl="$1"
  branch="$2"
  directory="$3"
  remotename="$4"

  [ "x$remoteurl" = "x" ] && die "usage: $cmdname clone <name> <url>"
  [ "x$branch" = "x" ] && branch="master"
  [ "x$directory" = "x" ] && directory="$(guess_dir_name "$remoteurl")"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    remotename="$curdir$directory"
  fi

  run git remote add "$remotename" "$remoteurl"
  run git config remote."$remotename".fetch refs/heads/\*:refs/remotes/"$remotename"/\*
  run git config --add remote."$remotename".fetch refs/tags/\*:refs/remotes/"$remotename"/tags/\*
  run git config remote."$remotename".tagopt --no-tags

  fetch "$remotename"
  merge "$remotename/$branch" "$(git rev-parse --show-prefix)$directory"
}


fetch_help=\
"$cmdname fetch [<remote>]: fetches objects from the remote repo
  remote: if unspecified, computed from the current directory.
"
fetch() {
  remotename="$1"
  if [ "x$remotename" = "x" ]; then
    curdir="$(git rev-parse --show-prefix)"
    [ "x$curdir" = "x" ] && die "You either need to be in a subdirectory or specify a branch name."
    remotename=${curdir%/}
    git remote show "$remotename" >/dev/null 2>&1
    [ "$?" != "0" ] && die "$remotename is not a subtree.  Run git remote to show possible subtrees."
  fi

  run_quiet git fetch -q "$remotename"
}


# TODO: merge should accept the directory name relative to the
# cwd.  Currently it requires it relative to the repo root!
merge_help=\
"$cmdname merge [remote]
  Merges the branch into the current directory of the repository
"
merge() {
  branch="$1"
  [ "x$branch" = "x" ] && die "usage: $cmdname merge <branch> [<destination>]"

  if [ "x$2" != "x" ]; then
    dest="$2"
  else
    dest="$(git rev-parse --show-prefix)$branch"
    [ "x$dest" = "x" ] && die "you need to be in a subdirectory!"
  fi

  if [ -e "$(git rev-parse --show-cdup)$dest" ]; then
    # If the destination already exists, we need to merge
    run_quiet git merge --squash -s subtree --no-commit "$branch"
  else
    # otherwise, just record the result as a merge and read the tree
    run_quiet git merge --squash -s ours --no-commit "$branch"
    run git read-tree --prefix="$dest" -u "$branch"
  fi
}



diff_help=\
"Diffs a subtree against the remote
"
diff() {
  branch="$1"

  [ "x$branch" = "x" ] && die "usage: $cmdname diff <branch>"

  run git diff-tree -p --no-commit-id "$branch"
}



help_help="Shows help text for the given command"

help() {
  if [ "x$1" = "x" ]; then
    echo \
"$cmdname, like git submodule, allows you to place another git project
into a subtree of your current project.  Unlike git submodule, however,
you can still branch and merge when it's in your repo.

   $cmdname add will_paginate git://github.com/mislav/will_paginate.git
   $cmdname merge will_paginate/master vendor/plugins/will_paginate
   git commit   # todo: should commit automatically
"
    return 0
  fi

  for i in $commands; do
    if [ "$i" = "$1" ]; then
      # echo $add_help if user typed 'gitree help add'
      echo "$(eval "echo \"\$${i}_help\"")"
      return 0
    fi
  done

  echo "Unknown command: $1"
  return 1
}



cmd="$1"
for i in $commands; do
  if [ "$i" = "$cmd" ]; then
    shift
    "$cmd" "$@"
    exit $?
  fi
done

if [ "x$cmd" = "x" ]; then
  echo "You must supply a command to execute!"
else
  echo "unknown command: $cmd"
fi
echo "  some $cmdname subcommands: $commands"
exit 1

